//Замена циклов с помощью рекурсии
//Рекурсия — это концепция, согласно которой функция может быть выражена через саму себя. Чтобы лучше понять это, начните с размышлений о следующей задаче: умножьте первые n (индекс элемента в массиве!!) элементов массива, чтобы получить произведение этих элементов. Используя цикл for, вы можете сделать это:
function multiply_1(arr, n) {
    let product = 1;
    for (let i = 0; i < n; i++) {
        product *= arr[i];
    }
    return product;
}

//Однако обратите внимание, что multiply(arr, n) == multiply(arr, n - 1) * arr[n - 1]. Это означает, что вы можете переписать умножение с точки зрения самого себя и вам никогда не понадобится использовать цикл.
function multiply_2(arr, n) {
    if (n <= 0) {
        return 1;
    } else {
        return multiply_2(arr, n - 1) * arr[n - 1];
    }
}

//Рекурсивная версия умножения работает следующим образом. В базовом случае, когда n <= 0, он возвращает 1. Для больших значений n он вызывает сам себя, но с n - 1. Этот вызов функции оценивается таким же образом, вызывая умножение снова до тех пор, пока n <= 0. В этот момент все функции могут возвращаться, и исходное умножение возвращает ответ.
// !!! Примечание. Рекурсивные функции должны иметь базовый случай, когда они возвращаются без повторного вызова функции (в этом примере, когда n <= 0), иначе они никогда не смогут завершить выполнение.

//Напишите рекурсивную функцию sum(arr, n), которая возвращает сумму первых n элементов массива arr.
const sum = (arr, n) => {
    if (n <= 0) {
        return 0;
    }
    if (n > arr.length) {
        return 'В нашем массиве есть только ' + arr.length + ' элементa'
    }
    return sum(arr, n - 1) + arr[n - 1];
}
console.log(sum([1], 0))
console.log(sum([2, 3, 4], 1))
console.log(sum([2, 3, 4, 5], 3))
console.log(sum([2, 3, 4, 5], 10))


//Оператор if проверяет, оценивает ли sum базовый случай, n <= 0, или нет. Если да, то sum возвращает ответ, 0 - сумму элементов от 0 до 0 включительно. В противном случае выполняется рекурсия путем вычисления более простого вызова функции sum(arr, n - 1). После возврата он добавляет к нему один элемент массива arr[n - 1] и возвращает эту сумму.

//В настоящее время я тоже работаю над этим, и я думаю, что наконец-то понял. Мне было непонятно, что n означает индекс массива. сумма функций (обр, п) { // Изменяем только код ниже этой строки если (п <= 0) { вернуть 0; } еще { возвращаемая сумма (обр, n-1) + обр[n-1] } // Изменяем только код над этой строкой } Итак, в: сумма( [2,3,4,5], 3) // обычно мы начинаем с индекса 3, но функция утверждает, что (n-1) является начальным индексом, поэтому n = 2 (значение 4 соответствует индексу 2) . Затем мы находим сумму массива до индекса 2. (2+3+4) = 9 Например: sum([2,3,4], 1) // обычно мы начинаем с индекса 1, но поскольку n=(n-1), мы находим сумму массива до индекса 0, который равен 2. Я надеюсь, что это имеет хоть какой-то смысл — и я надеюсь, что кто-то подтвердит, что я прав, лол.
function som(arr, n) {
    // Only change code below this line

    if (n > 0 && n <= arr.length) {
        return som(arr, n - 1) + arr[n - 1];
    } else if (n > arr.length) {
        return 'There are only ' + arr.length + ' items in array!';
    } else {
        return 0;
    }

    // Only change code above this line
}

console.log(som([1, 3, 7], 10));